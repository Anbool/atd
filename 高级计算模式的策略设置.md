## 概述
为了补充标准计算模式的多样性和复杂性，产品提供了策略设置的高级计算模式。在高级计算模式中，可以更加灵活地定义查询语句和触发条件，支持更多应用场景。
## 设置查询语句
支持标准的Elasticsearch(以下简称ES)查询语句
1. 选择索引，选择数据所在的索引。
2. 编辑框内，填写ES查询的body体，查询语句遵循标准的ES查询标准，示例如下：
  ```
    {
      "query": {
        "bool": {
          "must": [
            {
              "range": {
                "time_local": {
                  "gte": "now-5m",
                  "lte": "now"
                }
              }
            }
          ],
          "must_not": []
        }
      },
      "size": 10
    }
  ```

  PS: 更多查询语句可以参考如下链接文档：

  https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html

  主要涉及到结构化搜索，全文搜索，多字段搜索，近似匹配...等。

3. 查询结果。根据(1)选择的索引，以及(2)填写的查询语句，可在ES中检索到相应数据，这里用payload表示查询后的结果，该结果也是定义触发条件的输入。

## 定义触发条件
触发条件需要定义一个触发函数，支持JavaScript语法。
### 触发函数参数：
该函数的输入参数是上一步数据查询的结果-payload，在函数编写过程中可参考页面展示的数据查询结果。
### 触发函数返回值：
通过一系列的触发条件判断编写，
> 若策略触发，则该函数的返回值定义为策略的触发结果。

> 若策略没有触发，则该函数可不返回返回值，或着返回false。

一个简单的触发函数，示例如下：
``` 
function trigger(payload) {
    let result = "payload.hits.total=" + payload.hits.total
    if (payload.hits.total > 5) {
        return result;
    }
}
```
## 示例
### 场景一：5XX状态码占比异常事件
  - 描述：监控最近5分钟5XX状态码的数量，如果5XX的请求数在所有请求数中所占的比例超过一定值（假定为5%）则认为触发该事件，记录下当前5XX的数量及占比。
  - 思路：
    - 选择该事件数据来源的索引 - atd-statistics-domain-*
    - 编写Elasticsearch查询条件，根据描述可知，时间范围为最近五分钟，需要查询得到5XX的请求数量以及该时间段内所有请求数的数量。
    - 根据查询结果编写触发函数，判断占比是否超过5%，若超过则返回需要记录的数据。
  - 实现：
      ##### 设置查询条件：
      ```
      {
        "query": {
          "bool": {
            "must": [
              {
                "range": {
                  "time_local": {
                    "gte": "now-5m",
                    "lte": "now"
                  }
                }
              }
            ],
            "must_not": []
          }
        },
        "aggs": {
            "5xx_count_agg": {
                "sum": {
                    "field": "5xx_count"
                }
            },
            "request_count_agg": {
                "sum": {
                    "field": "request_count"
                }
            }
        },
        "size": 0
      }
      ```
      ##### 查询结果如下：
      ```
      {
        "took": 1,
        "timed_out": false,
        "_shards": {
          "total": 7,
          "successful": 7,
          "skipped": 0,
          "failed": 0
        },
        "hits": {
          "total": 13,
          "max_score": 0,
          "hits": []
        },
        "aggregations": {
          "request_count_agg": {
            "value": 24277
          },
          "5xx_count_agg": {
            "value": 3108
          }
        }
      }
      ```
      ##### 定义触发条件：
      ```
      function trigger(payload) {
          let count_5xx = 0;
          let request_count = 0;
          let proportion, result;
          if (payload.aggregations && payload.aggregations["5xx_count_agg"]) {
              count_5xx = payload.aggregations["5xx_count_agg"].value;
          }
          if (payload.aggregations && payload.aggregations.request_count_agg) {
              request_count = payload.aggregations.request_count_agg.value;
          }
          if (request_count) {
              proportion = count_5xx / request_count;
          }
          if (proportion > 0.05) {
              result = "5xx数量：" + count_5xx +",当前占比：" + proportion;
              return result;
          }
      }
     ```

## Q&A
### 如何进行接口请求？
在触发函数编写的过程中，本产品提供了封装好的接口请求函数fetchData，该函数的返回值为请求返回值。
请配合async/await的同步操作使用。即触发函数以async开头，接口请求函数以await开始。示例如下：

```
  fetchData(url, method, headers, body)，其中：
  url: 完整的请求地址，
  method: 请求方法， 
  headers: 请求的headers，不传时默认为{ 'Content-Type': 'application/json' }，
  body: 请求的body体
```
对于一个带接口请求的触发函数，示例如下：
```
async function trigger(payload) {
    let url = "http://xxx/test";
    let method = "get";
    let data = await fetchData(url, method);
    let result = "payload.hits.total=" + payload.hits.total;
    if (payload.hits.total > data.total) {
        return result;
    }
}
```
### 如何进行时间格式化？
对于触发函数中的时间格式化处理，本产品支持moment进行时间格式化。示例如下：
```
var time = moment().unix();
```
### 如何进行临时数据存储？
本产品内置了临时数据存储模块CacheStorage，可供用户进行数据的临时存储，以及后续使用。

该存储模块提供了三种处理数据的方法，分别为get，set，delete。请配合async/await的同步操作使用。

CacheStorage模块的使用具体描述如下：
```
const cache_storage = new CacheStorage('event');
cache_storage.get(key);
cache_storage.set(key, value, expire_time);
cache_storage.delete(key);
```
```
cache_storage.get(key)，其中：
参数：
  key: 数据存储的key值
返回值：
  若存在该key对应的value，且该数据没有过期，则返回value，否则返回null。
示例：
let value = await cache_storage.get(key);
```
```
cache_storage.set(key, value, expire_time)，其中：
参数：
  key: 数据存储的key;
  value: 存储的数据，支持number，string，object，array等格式;
  expire_time: 数据保存时间（秒），可选。若不填，默认数据保存30天;
返回值：
  若数据存储成功，返回true；失败则返回false。
示例：
  let key = 'total';
  let value = 100;
  let expire_time = 86400; //数据保存86400秒
  await set(key, value, expire_time);
```
```
cache_storage.delete(key)，其中：
参数：
  key: 数据存储的key值
返回值：
  若数据删除成功，返回true；失败则返回false。
示例：
  await cache_storage.delete(key);
```
### 如何发送邮件？
本产品提供内置的邮件发送函数`postEmail`，示例如下：
```
  function postEmail(mailData, SMTPConfig, callReady, callError)，其中：
  mailData: 发送邮件内容对象，包括to、title、content属性；
  SMTPConfig: 若需要使用自己的SMTP服务器，请传入相关配置包括host、port、user、password属性，可选；
  callReady: 发送成功回调，可选；
  callError: 发送失败回调，可选；
```
其中`mailData`参数，分使用本产品提供的SMTP服务和用户自身SMTP服务两种情况进行说明：
1. 使用本产品提供的SMTP，示例如下：
```
  let mailData = {}; //邮件信息
  mailData.to = xxx; //收件人邮箱地址，多个用分号分割
  mailData.title = xxx; //邮件主题
  mailData.content = xxx; //邮件内容
  postEmail(mailData);
```
2. 用户自身SMTP服务器，示例如下：
```
  let mailData = {}; //邮件信息
  mailData.to = xxx; //收件人邮箱地址，多个用分号分割
  mailData.title = xxx; //邮件主题
  mailData.content = xxx; //邮件内容
  let SMTPConfig = {}; //SMTP服务器信息
  SMTPConfig.host = xxx; //SMPT服务器地址
  SMTPConfig.port = xxx; //端口
  SMTPConfig.user = xxx; //发件邮箱
  SMTPConfig.password = xxx; //SMTP授权码
  postEmail(mailData, SMTPConfig);
```


